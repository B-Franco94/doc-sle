<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<chapter version="5.0" role="General" xml:id="cha-deployment-prep-uefi-httpboot"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Setting up a UEFI HTTP Boot Server</title>
 <info>
  <abstract>
   <para>
    This chapter describes how to set up and configure UEFI HTTP Boot server.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

<section xml:id="httpboot-intro">
  <title>Introduction</title>
  <para>
    HTTP Boot is a client-server combination of DHCP, DNS, and HTTP
    that provides the capability for system deployment over the
    network. HTTP Boot can be used as a high-performance replacement
    for PXE. HTTP Boot allows to boot a server from a URI over HTTP,
    quickly transferring large files, such as Linux kernel and root
    file system from servers outside of your local network.
  </para>
</section>
<section xml:id="httpboot-client">
  <title>Configuring the Client Machine</title>
  <para>
      Enabling HTTP Boot on a physical client machine depends on your
      specific hardware. Consult the documentation for further
      information on how to enable HTTP Boot on your particular
      machine.
    </para>
</section>
<section xml:id="httpboot-preparation">
  <title>Preparation</title>
      <para>
      The setup described here uses 192.168.111.0/24 (IPv4) and
      2001:db8:f00f:cafe::/64 (IPv6) IP subnets and the server IP
      addresses are 192.168.111.1(IPv4) and 2001:db8:f00f:cafe::1/64
      (IPv6) as examples. Adjust these values to match your specific
      setup.
    </para>
    <para>
      Install the following packages on the machine that you plan to
      use as a HTTP Boot server: <package>dhcp-server</package>,
      <package>apache2</package> (or <package>lighttpd</package>), and
      <package>dnsmasq</package>.
    </para>
    <section xml:id="httpboot-configure-server">
    <title>Configuring the Server</title>
    <section xml:id="dns_server">
      <title>DNS Server</title>
      <para>
	While configuring the DNS server is optional, this does allow
	you to assign a user-friendly name to the HTTP Boot server. To
	set up the DNS server, add the following to the
	<filename>/etc/dnsmasq.conf</filename> file:
      </para>
<screen>interface=eth0
addn-hosts=/etc/dnsmasq.d/hosts.conf</screen>
      <para>
	Assign a domain name to the IP addresses in the
      <filename>/etc/dnsmasq.d/hosts.conf</filename> file:
      </para>
<screen>192.168.111.1 www.httpboot.local
2001:db8:f00f:cafe::1 www.httpboot.local</screen>
      <para>
      Start the DNS server.
    </para>
<screen>systemctl start dnsmasq</screen>
    <note>
      <para>
      UEFI 2.7 replaces the device path of the HTTP Boot server with a
      DNS node. Therefore, we recommend using shim bootloaders from
      &slea; 15 or newer to avoid potential errors caused by the
      additional DNS node.
      </para>
    </note>
    <section xml:id="httpboot-dhcpv4-server">
      <title>Configuring the DHCPv4 Server</title>
      <para>
	Before setting up the DHCP servers, specify the interface for
	the DHCP servers in <filename>/etc/sysconfig/dhcpd</filename>:
      </para>
<screen>DHCPD_INTERFACE="eth0"
DHCPD6_INTERFACE="eth0"</screen>
    <para>
      This way, the DHCP servers provide the service
      on the <literal>eth0</literal> interface only.
    </para>
    <para>
      To set up a mixed DHCPv4 server for both PXE Boot and HTTP Boot,
      add the following configuration to the
      <filename>/etc/dhcpd.conf</filename> file:
    </para>
<screen>option domain-name-servers 192.168.111.1;
option routers 192.168.111.1;
default-lease-time 14400;
ddns-update-style none;
  subnet 192.168.111.0 netmask 255.255.255.0 {
    range dynamic-bootp 192.168.111.100 192.168.111.120;
    default-lease-time 14400;
    max-lease-time 172800;
    class "pxeclients"{
      match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
      next-server 192.168.111.1;
      filename "/bootx64.efi";
    }
    class "httpclients" {
      match if substring (option vendor-class-identifier, 0, 10) = "HTTPClient";
      option vendor-class-identifier "HTTPClient";
      filename "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
    }
}</screen>
    <para>
      Note that the DHCPv4 server must use the
      <literal>HTTPClient</literal> parameter for the vendor class ID,
      because the client uses it to identify an HTTP Boot offer.
</para>
    <para>
      Start the DHCP daemon:
    </para>
    <para>
      <literal>systemctl start dhcpd</literal>
    </para>
  </section>
  <section xml:id="httpboot-dhcpv6-server">
    <title>Configuring the DHCPv6 Server</title>
    <para>
      To set up the DHCPv6 server, add the following configuration to
      <filename>/etc/dhcpd6.conf</filename>:
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};
subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
        option dhcp6.name-servers 2001:db8:f00f:cafe::1;
        option dhcp6.vendor-class 0 10 "HTTPClient";
}</screen>
    <para>
      This configuration defines the type of the boot URL and the
      vendor class as well as other required options. Similar to the
      DHCPv4 settings, it is necessary to provide the boot URL, which
      must have an IPv6 address. Similar to the DHCPv4 configuration,
      it is necessary to specify the vendor class option. In DHCPv6,
      it consists of the enterprise number and the vendor class data
      (length and the content). Since the HTTP Boot driver ignores the
      enterprise number, you can set it to <literal>0</literal>. The
      content of the vendor class data has to be
      <literal>HTTPClient</literal>; Otherwise, the client ignores the
      offer.
    </para>
    <para>
      The older HTTP Boot implementation, which does not follow RFC
      3315, requires a different configuration:
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = string;
        subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi;
	option dhcp6.name-servers 2001:db8:f00f:cafe::1;
	option dhcp6.vendor-class "HTTPClient";
}</screen>
    <para>
      Start the <literal>dhcpv6</literal> daemon.
    </para>
<screen>systemctl start dhcpd6</screen>
    <para>
      Using the following configuration, it is possible to configure
      the DHCPv6 server for both PXE Boot and HTTP Boot:
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};

subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;

        class "PXEClient" {
	        match substring (option dhcp6.vendor-class, 6, 9);
	}

        subclass "PXEClient" "PXEClient" {
	        option dhcp6.bootfile-url "tftp://[2001:db8:f00f:cafe::1]/bootloader.efi";
	}

	class "HTTPClient"; {
	        match substring (option dhcp6.vendor-class, 6, 10);
	}

	subclass "HTTPClient" "HTTPClient" {
	        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
		option dhcp6.name-servers 2001:db8:f00f:cafe::1;
		option dhcp6.vendor-class 0 10 "HTTPClient";
	}
}</screen>
    <para>
      It is also possible to match the vendor class to a specific architecture, as follows:
    </para>
<screen>class "HTTPClient" {
        match substring (option dhcp6.vendor-class, 6, 21);
	}

subclass "HTTPClient" "HTTPClient":Arch:00016 {
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
	option dhcp6.name-servers 2001:db8:f00f:cafe::1;
	option dhcp6.vendor-class 0 10 "HTTPClient";
}</screen>
    <para>
      In this example, <literal>HTTPClient:Arch:00016</literal> refers
      to a x86_64 HTTP Boot client. This configuration allows the
      server to serve different architectures simultaneously.
    </para>
    <section xml:id="httpboot-firewall">
      <title>Firewall</title>
      <para>
        If DHCPv6 packets are dropped by the RP filter in the
        firewall, check its log. In case it contains the
        <literal>rpfilter_DROP</literal> entry, disable the filter
        using the following configuration in
        <filename>/etc/firewalld/firewalld.conf</filename>:
      </para>
      <para>
        <literal> IPv6_rpfilter=no</literal>
      </para>
    </section>
  </section>
  <section xml:id="httpboot-tftp_server">
    <title>Deploying a TFTP server (Optional)</title>
    <para>
      To provide support for both PXE and HTTP Boot, deploy a
      TFTP server. Install the <package>tftp</package> and start the
      service:
    </para>
<screen> systemctl start tftp.socket
systemctl start tftp.service</screen>
    <para>
      It is also necessary to install a specific
      <package>tftpboot-installation</package> package for use with
      PXE. Run the <command>zypper se tftpboot</command> command, to
      list of the available <package>tftp-installation</package>
      packages, then install the package for the desired system
      version and architecture, for example
      <package>tftpboot-installation-SLE-15-SP2-x86_64</package> For
      example, <package
      os="osuse">tftpboot-installation-openSUSE-<replaceable>VERSION</replaceable>-x86_64</package><package
      os="sles;sled">tftpboot-installation-SLE-<replaceable>VERSION</replaceable>-x86_64</package>
      (replace <replaceable>VERSION</replaceable> with the actual
      version). Copy the content of the <filename
      os="osuse">openSUSE-<replaceable>VERSION</replaceable>-x86_64</filename><filename
      os="sles;sled">SLE-<replaceable>VERSION</replaceable>-x86_64</filename>
      directory to the root directory of the TFTP server:
    </para>
<screen os="osuse">cp -r /usr/share/tftpboot-installation/openSUSE-<replaceable>VERSION</replaceable>-x86_64 /srv/tftpboot</screen><screen os="slas;sled">cp -r /usr/share/tftpboot-installation/SLE-<replaceable>VERSION</replaceable>-x86_64 /srv/tftpboot</screen>
    <para>
      For more information, refer to <filename
      os="osuse">/usr/share/tftpboot-installation/openSUSE-<replaceable>VERSION</replaceable>-x86_64/README</filename><filename
      os="sles;sled">/usr/share/tftpboot-installation/SLE-<replaceable>VERSION</replaceable>-x86_64/README</filename>
    </para>
  </section>
  <section xml:id="httpboot-http-server">
    <title>Setting up the HTTP Server</title>
    <para>
      Copy the entire content of the first system ISO image to the
      <filename
      os="osuse">/srv/www/htdocs/opensuse/</filename><filename
      os="sles;sled">/srv/www/htdocs/sle/</filename> directory. Edit
      then the <filename
      os="osuse">/srv/www/htdocs/opensuse/grub.cfg</filename><filename
      os="sles;sled">/srv/www/htdocs/sle/grub.cfg</filename> file. Use
      the following example as a reference:
    </para>
<screen>timeout=60
default=1

menuentry 'Installation IPv4' --class opensuse --class gnu-linux --class gnu --class os {
    set gfxpayload=keep
    echo 'Loading kernel ...'
    linuxefi /sle/boot/x86_64/loader/linux install=http://www.httpboot.local/sle
    echo 'Loading initial ramdisk ...'
    initrdefi /sle/boot/x86_64/loader/initrd
}

menuentry 'Installation IPv6' --class opensuse --class gnu-linux --class gnu --class os {
    set gfxpayload=keep
    echo 'Loading kernel ...'
    linuxefi /sle/boot/x86_64/loader/linux install=install=http://www.httpboot.local/sle ipv6only=1 ifcfg=*=dhcp6,DHCLIENT6_MODE=managed
    echo 'Loading initial ramdisk ...'
    initrdefi /sle/boot/x86_64/loader/initrd
}</screen>
    <section xml:id="httpboot-lighttpd">
      <title>Configuring lighttpd</title>
      <para>
        To enable the support for both IPv4 and IPv6 in lighttpd,
        modify <filename>/etc/lighttpd/lighttpd.conf</filename> as
        follows:
      </para>
<screen>##
## Use IPv6?
##
#server.use-ipv6 = "enable"
$SERVER["socket"] == "[::]:80" {  }</screen>
      <para>
        Start the <literal>lighttpd</literal> daemon:
      </para>
<screen>systemctl start lighttpd</screen>
    </section>
    <section xml:id="httpboot-apache2">
      <title>Configuring apache2</title>
      <para>
	Apache requires no additional configuration. Start the <literal>apache2</literal> daemon:
      </para>
<screen>systemctl start apache2</screen>
    </section>
  </section>
  <section xml:id="httpboot-http-server-ssl-support">
    <title>Enabling SSL Support for the HTTP Server (Optional)</title>
    <para>
      To use the HTTPS Boot, you need to convert an existing server
      certificate into the <literal>DER</literal> format and enroll it
      into the client's firmware.
    </para>
    <para>
      Assuming you already have a certificate installed on your
      server, convert it into the <literal>DER</literal> format for
      use with the client:
    </para>
<screen>openssl x509 -in <replaceable>CERTIFICATE</replaceable>.crt -outform der -out <replaceable>CERTIFICATE</replaceable>.der</screen>

    <section xml:id="httpboot-enroll-certificate-physical-machine">
      <title>Enroll The Server Certificate into the Client Firmware</title>
      <para>
	The exact procedure of enrolling the converted certificate
	depends on the specific implementation of the client
	firmware. For certain hardware, you have to enroll the
	certificate manually via the firmware UI using an external
	storage device with the certificate on it. Machines with
	Redfish support can enroll the certificate remotely. Consult
	documentation for your specific hardware for more information
	on enrolling certificates.
      </para>
  </section>
    <section xml:id="lighttpd">
      <title>Enabling SSL Support in lighttpd</title>
      <para>
        Since lighttpd needs the private key and the certificate in the
        same file, unify them using the following command:
      </para>
<screen>cat <replaceable>CERTIFICATE</replaceable>.crt server.key &gt; <replaceable>CERTIFICATE</replaceable>.pem</screen>
      <para>
        Copy
        <filename><replaceable>CERTIFICATE</replaceable>.pem</filename>
        to the <filename>/etc/ssl/private/</filename> directory.
      </para>
<screen>cp server-almighty.pem /etc/ssl/private/
chown -R root:lighttpd /etc/ssl/private/server-almighty.pem
chmod 640 /etc/ssl/private/server-almighty.pem</screen>
      <para>
        Make sure that <literal>mod_openssl</literal> is listed
        in the <literal>server.modules</literal> section of the
        <filename>/etc/lighttpd/modules.conf</filename> file, for
        example:
      </para>
<screen>server.modules = (
  "mod_access",
  "mod_openssl",
)</screen>
      <para>
        Add the following lines to <literal>SSL Support</literal>
        section in <filename>/etc/lighttpd/lighttpd.conf</filename>:
      </para>
<screen># IPv4
$SERVER["socket"] == ":443" {
    ssl.engine                 = "enable"
    ssl.pemfile                = "/etc/ssl/private/server-almighty.pem"
}
# IPv6
$SERVER["socket"] == "[::]:443" {
    ssl.engine                 = "enable"
    ssl.pemfile                = "/etc/ssl/private/server-almighty.pem"
}</screen>
      <para>
        Restart lighttpd to activate SSL support:
      </para>
<screen>systemctl restart lighttpd</screen>
    </section>
    <section xml:id="apache2_1">
      <title>apache2</title>
      <para>
        Before we start to configure apache, we have to check
        <emphasis role="strong">/etc/sysconfig/apache2</emphasis> first.
      </para>
      <para>
        The SSL support of apache is controlled by
        <emphasis role="strong">APACHE_SERVER_FLAGS</emphasis>, so we
        have to add the <emphasis role="strong">SSL</emphasis> flag.
      </para>
      <para>
        <literal> APACHE_SERVER_FLAGS="SSL"</literal>
      </para>
      <para>
        Besides, make sure that <emphasis role="strong">ssl</emphasis>
        is in <emphasis role="strong">APACHE_MODULES</emphasis>. For
        example:
      </para>
      <para>
        <literal> APACHE_MODULES="actions alias auth_basic authn_file authz_host authz_groupfile authz_core authz_user autoindex cgi dir env expires include log_config mime negotiation setenvif </literal><emphasis role="strong"><literal>ssl</literal></emphasis><literal> socache_shmcb userdir reqtimeout authn_core headers proxy proxy_http proxy_wstunnel"</literal>
      </para>
      <para>
        Next, copy the private key and the certificate to /etc/apache2/.
      </para>
<literallayout><literal> # cp server.key /etc/apache2/ssl.key/</literal>
<literal> # chown wwwrun /etc/apache2/ssl.key/server.key</literal>
<literal> # chmod 600 /etc/apache2/ssl.key/server.key</literal>
<literal> # cp server.crt /etc/apache2/ssl.crt/</literal></literallayout>
      <para>
        Create the ssl vhost configuration.
      </para>
<literallayout><literal> # cd /etc/apache2/vhosts.d</literal>
<literal> # cp vhost-ssl.template vhost-ssl.conf</literal></literallayout>
      <para>
        Edit /etc/apache2/vhosts.d/vhost-ssl.conf to change the private
        key and the certificate:
      </para>
<literallayout><literal> SSLCertificateFile /etc/apache2/ssl.crt/server.crt</literal>
<literal> SSLCertificateKeyFile /etc/apache2/ssl.key/server.key</literal></literallayout>
      <para>
        Restart apache to activate the SSL support:
      </para>
      <para>
        <literal> # systemctl restart apache2</literal>
      </para>
    </section>
    <section xml:id="modify_dhcp_configuration">
      <title>Modify DHCP configuration</title>
      <para>
        Last, remember to replace the
        "<link xlink:href="http://">http://</link>" prefix
        with "<link xlink:href="https://">https://</link>" in
        the dhcpd.conf/dhcpd6.conf and restart the dhcp server.
      </para>
<literallayout><literal> # systemctl restart dhcpd</literal>
<literal> # systemctl restart dhcpd6</literal></literallayout>
    </section>
    <section xml:id="changes_in_grub.cfg">
      <title>Changes in grub.cfg</title>
      <para>
        Since we create a self-signed certificate for our HTTPS server,
        if we specify the HTTPS url in grub.cfg, the SLE/openSUSE
        installation system may fail to verify the certificate and
        refuse to download files from our HTTPS server.
      </para>
      <para>
        There are two possible solutions.
      </para>
      <para>
        1. Add <emphasis role="strong">ssl.certs=0</emphasis> to disable
        the certificate verification. For example:
      </para>
      <para>
        <literal> linuxefi /sle/boot/x86_64/loader/linux install=</literal><emphasis role="strong"><link xlink:href="https://www.httpboot.local/sle"><literal>https://www.httpboot.local/sle</literal></link></emphasis><literal> </literal><emphasis role="strong"><literal>ssl.certs=0</literal></emphasis>
      </para>
      <para>
        2. Create an initrd containing the server certificate. By
        default, the installation system searches the trusted
        certificates in /var/lib/ca-certificates/openssl/ and
        /var/lib/ca-certificates/pem/, so we have to create an initrd
        containing our server certificate in those directory. Here is
        the example of commands:
      </para>
<literallayout><literal> ## Create new directories containing the target path</literal>
<literal> $ mkdir -p initrd-new/var/lib/ca-certificates/openssl/</literal>
<literal> $ mkdir -p initrd-new/var/lib/ca-certificates/pem/</literal>
<literal> </literal>
<literal> ## Copy our server certificate to the target paths</literal>
<literal> $ cp server.crt initrd-new/var/lib/ca-certificates/openssl/my-ca.pem</literal>
<literal> $ cp server.crt initrd-new/var/lib/ca-certificates/pem/my-ca.pem</literal>
<literal> </literal>
<literal> ## Create the link file, </literal><hash><literal>.0, to make the certificate be trusted</literal>
<literal> $ ln -sr initrd-new/var/lib/ca-certificates/openssl/my-ca.pem initrd-new/var/lib/ca-certificates/openssl/`openssl x509 -hash -noout -in server.crt`.0</literal>
<literal> $ ln -sr initrd-new/var/lib/ca-certificates/pem/my-ca.pem initrd-new/var/lib/ca-certificates/pem/`openssl x509 -hash -noout -in server.crt`.0</literal>
<literal> </literal>
<literal> ## Change the working directory to 'initrd-new'</literal>
<literal> $ cd initrd-new</literal>
<literal> </literal>
<literal> ## Make sure the whole path is owned by root</literal>
<literal> $ sudo chown -R root:root var</literal>
<literal> </literal>
<literal> ## Create initrd (ssl.img)</literal>
<literal> $ find . | cpio --quiet -H newc -o | gzip -9 -n &gt; ../ssl.img</literal>
<literal> </literal>
<literal> ## Back to the upper directory for the further actions</literal>
<literal> $ cd ..</literal></literallayout>
      <para>
        You can check the content of ssl.img with
        <emphasis role="strong">lsinitrd</emphasis>. For example:
      </para>
<literallayout><literal> $ lsinitrd ssl.img</literal>
<literal> Image: ssl.img: 4.0K</literal>
<literal> ========================================================================</literal>
<literal> Version: </literal>
<literal> </literal>
<literal> Arguments: </literal>
<literal> dracut modules:</literal>
<literal> ========================================================================</literal>
<literal> drwxr-xr-x   3 johndoe  users           0 Sep  3 10:09 .</literal>
<literal> drwxr-xr-x   3 root     root            0 Sep  3 16:27 var</literal>
<literal> drwxr-xr-x   3 root     root            0 Sep  3 16:27 var/lib</literal>
<literal> drwxr-xr-x   3 root     root            0 Sep  3 16:27 var/lib/ca-certificates</literal>
<literal> drwxr-xr-x   2 root     root            0 Sep  3 16:28 var/lib/ca-certificates/openssl</literal>
<literal> lrwxrwxrwx   1 root     root            9 Sep  3 16:28 var/lib/ca-certificates/openssl/c6bea024.0 -&gt; my-ca.pem</literal>
<literal> -rw-r--r--   1 root     root         2114 Sep  3 16:28 var/lib/ca-certificates/openssl/my-ca.pem</literal>
<literal> drwxr-xr-x   2 root     root            0 Sep  3 16:28 var/lib/ca-certificates/pem</literal>
<literal> lrwxrwxrwx   1 root     root            9 Sep  3 16:28 var/lib/ca-certificates/pem/c6bea024.0 -&gt; my-ca.pem</literal>
<literal> -rw-r--r--   1 root     root         2114 Sep  3 16:28 var/lib/ca-certificates/pem/my-ca.pem</literal>
<literal> ========================================================================</literal></literallayout>
      <para>
        Now we need to copy <emphasis role="strong">ssl.img</emphasis>
        to the directory of initrd, e.g.
        /srv/www/htdocs/sle/boot/x86_64/loader/, and modify
        <emphasis role="strong">grub.cfg</emphasis> to add ssl.img. For
        example:
      </para>
<literallayout><literal> echo 'Loading kernel ...'</literal>
<literal> linuxefi /sle/boot/x86_64/loader/linux install=</literal><emphasis role="strong"><link xlink:href="https://www.httpboot.local/sle"><literal>https://www.httpboot.local/sle</literal></link></emphasis>
<literal> echo 'Loading initial ramdisk ...'</literal>
<literal> initrdefi /sle/boot/x86_64/loader/initrd </literal><emphasis role="strong"><literal>/sle/boot/x86_64/loader/ssl.img</literal></emphasis></literallayout>
      <para>
        NOTE: A simple bash script to create initrd is available:
        <link xlink:href="https://github.com/lcp/uefi-fun/blob/master/packcert/packcert.sh">https://github.com/lcp/uefi-fun/blob/master/packcert/packcert.sh</link>
      </para>
      <para>
        Usage:
      </para>
      <para>
        <literal> $ sh packcert.sh server.crt ssl.img</literal>
      </para>
    </section>
  </section>
  <section xml:id="container_services">
    <title>Container Services</title>
    <para>
      For the quick test, mightyboot(*) can create the services with
      containers. Just edit <emphasis role="strong">env</emphasis> to
      match the host network configuration and type
    </para>
    <para>
      <literal> $ docker-compose up</literal>
    </para>
    <para>
      If the settings are good, it will bring up dhcp, dhcp6, dnsmasq,
      and lighttpd services on the given network interface and make them
      ready to test.
    </para>
    <para>
      (*)
      <link xlink:href="https://github.com/lcp/mightyboot">https://github.com/lcp/mightyboot</link>
    </para>
  </section>
</section>
<section xml:id="launch_the_client">
  <title>Launch The Client</title>
  <section xml:id="physical_machine_2">
    <title>Physical Machine</title>
    <para>
      If the firmware already supports HTTPBoot, just plug in the cable
      and choose the correct boot option.
    </para>
  </section>
  <section xml:id="virtual_machine_2">
    <title>Virtual Machine</title>
    <para>
      Now it's time to set up a virtual machine as the HTTPBoot client.
      There are a few qemu options needed to create a UEFI virtual
      machine.
    </para>
    <orderedlist spacing="compact">
      <listitem>
        <para>
          Specify the firmware
        </para>
      </listitem>
    </orderedlist>
<literallayout><literal> -drive if=pflash,format=raw,readonly,file=/usr/share/qemu/ovmf-x86_64-code.bin \</literal>
<literal> -drive if=pflash,format=raw,file=ovmf-x86_64-vars.bin</literal></literallayout>
    <para>
      Please note that ovmf-x86_64-vars.bin must be writable. Just copy
      /usr/share/qemu/ovmf-x86_64-vars.bin to the working directory.
    </para>
    <orderedlist spacing="compact">
      <listitem>
        <para>
          Specify the network device
        </para>
      </listitem>
    </orderedlist>
<literallayout><literal> -netdev tap,id=hostnet0,ifname=tap0,script=no,downscript=no \</literal>
<literal> -device virtio-net-pci,romfile=,netdev=hostnet0</literal></literallayout>
    <para>
      Since the host uses tap0 to communicate with the guest, we must
      specify the interface. "romfile=" is to disable the iPXE
      support so the virtual machine will use the native PXE and
      HTTPBoot functions from OVMF instead from iPXE.
    </para>
    <para>
      The complete qemu command would be like this:
    </para>
<literallayout><literal> $ qemu-system-x86_64 -enable-kvm \</literal>
<literal>                      -drive if=pflash,format=raw,readonly,file=/usr/share/qemu/ovmf-x86_64-code.bin \</literal>
<literal>                      -drive if=pflash,format=raw,file=ovmf-vars.bin \</literal>
<literal>                      -hda fat:hda-contents/ -monitor stdio \</literal>
<literal>                      -netdev tap,id=hostnet0,ifname=tap0,script=no,downscript=no \</literal>
<literal>                      -device virtio-net-pci,romfile=,netdev=hostnet0</literal></literallayout>
    <para>
      If you are using libvirt, then you can use "rom bar" to
      disable iPXE support. For example:
    </para>
    <programlisting language="xml">
    &lt;interface type='bridge'&gt;
      &lt;mac address='00:11:22:33:44:55'/&gt;
      &lt;source bridge='br0'/&gt;
      &lt;model type='virtio'/&gt;
      &lt;rom bar='off'/&gt;
      &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/&gt;
    &lt;/interface&gt;
</programlisting>
    <para>
      When the TianoCore logo shows, press "ESC" to enter the
      firmware menu.
    </para>
    <para>
      Image:Boot-logo.png
    </para>
    <para>
      Press "DOWN" to go to "Boot Manager" and press
      "Enter".
    </para>
    <para>
      Image:Boot-manager.png
    </para>
    <para>
      There will be several boot options. Choose the boot option with
      the "HTTP" prefix.
    </para>
    <para>
      For example:
    </para>
    <para>
      HTTPBoot IPv4
    </para>
    <para>
      Image:Httpv4.png
    </para>
    <para>
      HTTPBoot IPv6
    </para>
    <para>
      Image:Httpv6.png
    </para>
    <para>
      Just choose one of the boot options, and the firmware will start
      to download your UEFI application and execute it!
    </para>
    <para>
      Another way to test http boot is to download a iso image from a
      URL. The benefit of this way is that you don't need to setup DHCP
      on host machine, and it only needs http server.
    </para>
    <para>
      The first step is putting iso file to /srv/www/htdocs on server
      side:
    </para>
    <para>
      e.g. /srv/www/htdocs/openSUSE-Leap-42.1-NET-x86_64.iso
    </para>
    <para>
      On client code, you should launch UEFI firmware UI:
    </para>
    <para>
      Device Manager -&gt; Network Device List
    </para>
    <para>
      Image:Uefi-http-boot-iso-0001.png
    </para>
    <para>
      e.g. IPv4
    </para>
    <para>
      Image:Uefi-http-boot-iso-0002.png
    </para>
    <para>
      Enable DHCP or you can set static ip
    </para>
    <para>
      Image:Uefi-http-boot-iso-0003.png
    </para>
    <para>
      Create a boot option by "HTTP Boot Configuration"
    </para>
    <para>
      Image:Uefi-http-boot-iso-0004.png
    </para>
    <para>
      Edit "Boot URI", point to the position of ISO file
    </para>
    <para>
      Image:Uefi-http-boot-iso-0005.png
    </para>
    <para>
      Select "UEFI HTTP" to boot to the ISO image
    </para>
    <para>
      Image:Uefi-http-boot-iso-0006.png
    </para>
  </section>
</section>
<section xml:id="see_also">
  <title>See also</title>
  <section xml:id="related_articles">
    <title>Related articles</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <link xlink:href="openSUSE:UEFI_Secure_boot_using_qemu-kvm">openSUSE:UEFI_Secure_boot_using_qemu-kvm</link>
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section xml:id="external_links">
    <title>External links</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <link xlink:href="http://www.tianocore.org/ovmf/">OVMF</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link xlink:href="http://www.linux-kvm.org/downloads/lersek/ovmf-whitepaper-c770f8c.txt">Open
          Virtual Machine Firmware (OVMF) Status Report</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link xlink:href="https://fedoraproject.org/wiki/Using_UEFI_with_QEMU">fedora:
          Using UEFI with QEMU</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link xlink:href="https://lkml.org/lkml/2016/6/3/85">LKML:
          libnvdimm, nfit: treat volatile virtual CD region as read-only
          pmem</link>
        </para>
      </listitem>
    </itemizedlist>
  </section>
</section>
</chapter>
