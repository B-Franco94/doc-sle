<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<chapter version="5.0" role="General" xml:id="cha-deployment-prep-uefi-httpboot"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Setting up a UEFI HTTP Boot Server</title>
 <info>
  <abstract>
   <para>
    This chapter describes how to set up and configure UEFI HTTP Boot server.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

<section xml:id="httpboot-intro">
  <title>Introduction</title>
  <para>
    HTTP Boot is a client-server combination of DHCP, DNS, and HTTP
    that provides the capability for system deployment over the
    network. HTTP Boot can be used as a high-performance replacement
    for PXE. HTTP Boot allows to boot a server from a URI over HTTP,
    quickly transferring large files, such as Linux kernel and root
    file system from servers outside of your local network.
  </para>
</section>
<section xml:id="httpboot-client">
  <title>Configuring the Client Machine</title>
  <para>
      Enabling HTTP Boot on a physical client machine depends on your
      specific hardware. Consult the documentation for further
      information on how to enable HTTP Boot on your particular
      machine.
    </para>
</section>
<section xml:id="httpboot-preparation">
  <title>Preparation</title>
      <para>
      The setup described here uses 192.168.111.0/24 (IPv4) and
      2001:db8:f00f:cafe::/64 (IPv6) IP subnets and the server IP
      addresses are 192.168.111.1(IPv4) and 2001:db8:f00f:cafe::1/64
      (IPv6) as examples. Adjust these values to match your specific
      setup.
    </para>
    <para>
      Install the following packages on the machine that you plan to
      use as a HTTP Boot server: <package>dhcp-server</package>,
      <package>apache2</package> (or <package>lighttpd</package>), and
      <package>dnsmasq</package>.
    </para>
    <section xml:id="httpboot-configure-server">
    <title>Configuring the Server</title>
    <section xml:id="dns_server">
      <title>DNS Server</title>
      <para>
	While configuring the DNS server is optional, this does allow
	you to assign a user-friendly name to the HTTP Boot server. To
	set up the DNS server, add the following to the
	<filename>/etc/dnsmasq.conf</filename> file:
      </para>
<screen>interface=eth0
addn-hosts=/etc/dnsmasq.d/hosts.conf</screen>
      <para>
	Assign a domain name to the IP addresses in the
      <filename>/etc/dnsmasq.d/hosts.conf</filename> file:
      </para>
<screen>192.168.111.1 www.httpboot.local
2001:db8:f00f:cafe::1 www.httpboot.local</screen>
      <para>
      Start the DNS server.
    </para>
<screen>systemctl start dnsmasq</screen>
    <note>
      <para>
      UEFI 2.7 replaces the device path of the HTTP Boot server with a
      DNS node. Therefore, we recommend using shim bootloaders from
      &slea; 15 or newer to avoid potential errors caused by the
      additional DNS node.
      </para>
    </note>
    <section xml:id="httpboot-dhcpv4-server">
      <title>Configuring the DHCPv4 Server</title>
      <para>
	Before setting up the DHCP servers, specify the interface for
	the DHCP servers in <filename>/etc/sysconfig/dhcpd</filename>:
      </para>
<screen>DHCPD_INTERFACE="eth0"
DHCPD6_INTERFACE="eth0"</screen>
    <para>
      This way, the DHCP servers provide the service
      on the <literal>eth0</literal> interface only.
    </para>
    <para>
      To set up a mixed DHCPv4 server for both PXE Boot and HTTP Boot,
      add the following configuration to the
      <filename>/etc/dhcpd.conf</filename> file:
    </para>
<screen>option domain-name-servers 192.168.111.1;
option routers 192.168.111.1;
default-lease-time 14400;
ddns-update-style none;
  subnet 192.168.111.0 netmask 255.255.255.0 {
    range dynamic-bootp 192.168.111.100 192.168.111.120;
    default-lease-time 14400;
    max-lease-time 172800;
    class "pxeclients"{
      match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
      next-server 192.168.111.1;
      filename "/bootx64.efi";
    }
    class "httpclients" {
      match if substring (option vendor-class-identifier, 0, 10) = "HTTPClient";
      option vendor-class-identifier "HTTPClient";
      filename "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
    }
}</screen>
    <para>
      Note that the DHCPv4 server must use the
      <literal>HTTPClient</literal> parameter for the vendor class ID,
      because the client uses it to identify an HTTP Boot offer.
</para>
    <para>
      Start the DHCP daemon:
    </para>
    <para>
      <literal>systemctl start dhcpd</literal>
    </para>
  </section>
  <section xml:id="httpboot-dhcpv6-server">
    <title>Configuring the DHCPv6 Server</title>
    <para>
      To set up the DHCPv6 server, add the following configuration to
      <filename>/etc/dhcpd6.conf</filename>:
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};
subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
        option dhcp6.name-servers 2001:db8:f00f:cafe::1;
        option dhcp6.vendor-class 0 10 "HTTPClient";
}</screen>
    <para>
      This configuration defines the type of the boot URL and the
      vendor class as well as other required options. Similar to the
      DHCPv4 settings, it is necessary to provide the boot URL, which
      must have an IPv6 address. Similar to the DHCPv4 configuration,
      it is necessary to specify the vendor class option. In DHCPv6,
      it consists of the enterprise number and the vendor class data
      (length and the content). Since the HTTP Boot driver ignores the
      enterprise number, you can set it to <literal>0</literal>. The
      content of the vendor class data has to be
      <literal>HTTPClient</literal>; Otherwise, the client ignores the
      offer.
    </para>
    <para>
      The older HTTP Boot implementation, which does not follow RFC
      3315, requires a different configuration:
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = string;
        subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi;
	option dhcp6.name-servers 2001:db8:f00f:cafe::1;
	option dhcp6.vendor-class "HTTPClient";
}</screen>
    <para>
      Start the DHCPv6 daemon.
    </para>
<screen>systemctl start dhcpd6</screen>
    <para>
      Using the following configuration, it is possible to configure
      the DHCPv6 server for both PXE Boot and HTTP Boot:
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};

subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;

        class "PXEClient" {
	        match substring (option dhcp6.vendor-class, 6, 9);
	}

        subclass "PXEClient" "PXEClient" {
	        option dhcp6.bootfile-url "tftp://[2001:db8:f00f:cafe::1]/bootloader.efi";
	}

	class "HTTPClient"; {
	        match substring (option dhcp6.vendor-class, 6, 10);
	}

	subclass "HTTPClient" "HTTPClient" {
	        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
		option dhcp6.name-servers 2001:db8:f00f:cafe::1;
		option dhcp6.vendor-class 0 10 "HTTPClient";
	}
}</screen>
    <para>
      It is also possible to match the vendor class to a specific architecture, as follows:
    </para>
<screen>class "HTTPClient" {
        match substring (option dhcp6.vendor-class, 6, 21);
	}

subclass "HTTPClient" "HTTPClient":Arch:00016 {
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
	option dhcp6.name-servers 2001:db8:f00f:cafe::1;
	option dhcp6.vendor-class 0 10 "HTTPClient";
}</screen>
    <para>
      In this example, <literal>HTTPClient:Arch:00016</literal> refers
      to a x86_64 HTTP Boot client. This configuration allows the
      server to serve different architectures simultaneously.
    </para>
    <section xml:id="httpboot-firewall">
      <title>Firewall</title>
      <para>
        If DHCPv6 packets are dropped by the RP filter in the
        firewall, check its log. In case it contains the
        <literal>rpfilter_DROP</literal> entry, disable the filter
        using the following configuration in
        <filename>/etc/firewalld/firewalld.conf</filename>:
      </para>
      <para>
        <literal> IPv6_rpfilter=no</literal>
      </para>
    </section>
  </section>
  <section xml:id="httpboot-tftp_server">
    <title>TFTP server(Optional)</title>
    <para>
      To provide support for both PXE and HTTP Boot, you must deploy a
      TFTP server. Install the <package>tftp</package> and start the
      service:
    </para>
<screen> systemctl start tftp.socket
systemctl start tftp.service</screen>
    <para>
      It is also necessary to install a specific
      <package>tftpboot-installation</package> package for use with
      PXE. Run the <command>zypper se tftpboot</command> command, to
      list of the available <package>tftp-installation</package>
      packages, then install the package and bootloader for the
      desired system version and architecture, for example
      <package>tftpboot-installation-SLE-15-SP2-x86_64</package> For
      example, <package
      os="osuse">tftpboot-installation-openSUSE-<replaceable>VERSION</replaceable>-x86_64</package><package
      os="sles;sled">tftpboot-installation-SLE-<replaceable>VERSION</replaceable>-x86_64</package>
      (replace <replaceable>VERSION</replaceable> with the actual
      version). Copy the content of the <filename
      os="osuse">openSUSE-<replaceable>VERSION</replaceable>-x86_64</filename><filename
      os="sles;sled">SLE-<replaceable>VERSION</replaceable>-x86_64</filename> directory to
      the root directory of the TFTP server:
    </para>
<screen os="osuse">cp -r /usr/share/tftpboot-installation/openSUSE-<replaceable>VERSION</replaceable>-x86_64 /srv/tftpboot</screen><screen os="slas;sled">cp -r /usr/share/tftpboot-installation/SLE-<replaceable>VERSION</replaceable>-x86_64 /srv/tftpboot</screen>
    <para>
      For more information, refer to <filename
      os="osuse">/usr/share/tftpboot-installation/openSUSE-<replaceable>VERSION</replaceable>-x86_64/README</filename><filename
      os="sles;sled">/usr/share/tftpboot-installation/SLE-<replaceable>VERSION</replaceable>-x86_64/README</filename>
    </para>
  </section>
  <section xml:id="http_server">
    <title>HTTP Server</title>
    <para>
      For the complete SLE/openSUSE HTTPBoot installation, copy every
      file in the first iso image to /srv/www/htdocs/sle/ or
      /srv/www/htdocs/opensuse/. Then, edit
      /srv/www/htdocs/sle/EFI/BOOT/grub.cfg to fit your needs. An
      example of grub.cfg:
    </para>
<literallayout><literal> timeout=60</literal>
<literal> default=1</literal>
<literal> </literal>
<literal> menuentry 'Installation IPv4' --class opensuse --class gnu-linux --class gnu --class os {</literal>
<literal>   set gfxpayload=keep</literal>
<literal>   echo 'Loading kernel ...'</literal>
<literal>   linuxefi /sle/boot/x86_64/loader/linux install=</literal><link xlink:href="http://www.httpboot.local/sle"><literal>http://www.httpboot.local/sle</literal></link>
<literal>   echo 'Loading initial ramdisk ...'</literal>
<literal>   initrdefi /sle/boot/x86_64/loader/initrd</literal>
<literal> }</literal>
<literal> </literal>
<literal> menuentry 'Installation IPv6' --class opensuse --class gnu-linux --class gnu --class os {</literal>
<literal>   set gfxpayload=keep</literal>
<literal>   echo 'Loading kernel ...'</literal>
<literal>   linuxefi /sle/boot/x86_64/loader/linux install=</literal><link xlink:href="http://www.httpboot.local/sle"><literal>http://www.httpboot.local/sle</literal></link><literal> ipv6only=1 ifcfg=*=dhcp6,DHCLIENT6_MODE=managed</literal>
<literal>   echo 'Loading initial ramdisk ...'</literal>
<literal>   initrdefi /sle/boot/x86_64/loader/initrd</literal>
<literal> }</literal></literallayout>
    <para>
      The SLE Deployment Guide(*) may provide more information for the
      installation server setup.
    </para>
    <para>
      (*)
      <link xlink:href="https://www.suse.com/documentation/sles-12/book_sle_deployment/data/part_installserver.html">https://www.suse.com/documentation/sles-12/book_sle_deployment/data/part_installserver.html</link>
    </para>
    <section xml:id="lighttpd">
      <title>lighttpd</title>
      <para>
        There are some modification is necessary to make lighttpd
        support both IPv4 and IPv6. Edit /etc/lighttpd/lighttpd.conf
      </para>
<literallayout><literal> ##</literal>
<literal> ## Use IPv6?</literal>
<literal> ##</literal>
<literal> #server.use-ipv6 = &quot;enable&quot;</literal>
<literal> $SERVER[&quot;socket&quot;] == &quot;[::]:80&quot; {  }</literal></literallayout>
      <para>
        When server.use-ipv6 is enabled, it would make lighttpd only
        listen to IPv6, so we remove it and add an new IPv6 section with
        the default options.
      </para>
      <para>
        Start the lighttpd daemon:
      </para>
      <para>
        <literal> # systemctl start lighttpd</literal>
      </para>
    </section>
    <section xml:id="apache2">
      <title>apache2</title>
      <para>
        Start the apache daemon:
      </para>
      <para>
        <literal> # systemctl start apache2</literal>
      </para>
    </section>
  </section>
  <section xml:id="ssl_support_for_http_serveroptional">
    <title>SSL Support for HTTP Server(Optional)</title>
    <para>
      The TLS protocol was written in the UEFI spec since 2.5, and the
      latest OVMF already supports HTTPS Boot. For testing, we can
      create a self-signed certificate with
      <emphasis role="strong">openssl</emphasis>:
    </para>
    <para>
      <literal> $ openssl req -newkey rsa:4096 -nodes -keyout server.key -x509 -days 365 -out server.crt</literal>
    </para>
    <para>
      Since we choose &quot;www.httpboot.local&quot; as our domain name,
      please use &quot;www.httpboot.local&quot; for &quot;Common
      Name&quot;.
    </para>
    <para>
      Convert the certificate into DER format for the client:
    </para>
    <para>
      <literal> $ openssl x509 -in server.crt -outform der -out server.der</literal>
    </para>
    <para>
      Please note that this certificate is <emphasis role="strong">only
      for testing</emphasis> and
      <emphasis role="strong">NEVER</emphasis> use this certificate in
      the production machine.
    </para>
    <section xml:id="enroll_the_server_certificate_into_the_client_firmware">
      <title>Enroll The Server Certificate into The Client
      Firmware</title>
      <para>
        You have to enroll the server certificate (server.der) in the
        client side before using HTTPS Boot or the client would fail to
        connect to the server. The method to enroll the server
        certificate depends on the implementation of the client
        firmware.
      </para>
      <section xml:id="physical_machine_1">
        <title>Physical Machine</title>
        <para>
          To enroll the server certificate into a physical machine, you
          may need to plug in a USB stick which contains the certificate
          file and enroll it manually with the firmware UI. On the other
          hand, some high-end servers with Redfish support can enroll
          the certificate remotely. For example, the HPE iLO5 manual
          provides the
          <link xlink:href="https://hewlettpackard.github.io/ilo-rest-api-docs/ilo5/#https-boot-tls-configuration">instructions</link>
          to enroll the certificate through its Restful API.
        </para>
      </section>
      <section xml:id="virtual_machine_1">
        <title>Virtual Machine</title>
        <para>
          OVMF provides a menu in &quot;Device Manager&quot; -&gt;
          &quot;Tls Auth Configuration&quot;, and the user can enroll
          the server certificate from a file accessible to OVMF.
        </para>
        <para>
          Besides enrolling the certificate manually, it's possible to
          configure the trusted certificates for OVMF with
          &quot;-fw_cfg&quot;. Since
          <link xlink:href="https://github.com/tianocore/edk2/commit/9c7d0d499296e444e39e9b6b34d8c121a325b295">9c7d0d49929</link>,
          OVMF supports reading the certificate list from the fw_cfg
          entry,
          <emphasis role="strong">etc/edk2/https/cacerts</emphasis>. The
          certificate list has to be in the format of Signature
          Database.
        </para>
        <para>
          To create the certificate list with
          <emphasis role="strong">efisiglist</emphasis>:
        </para>
        <para>
          <literal> $ efisiglist -a server.der -o certs.db</literal>
        </para>
        <para>
          After creating the certificate list, append the following
          command to specify the fw_cfg entry:
        </para>
        <para>
          <literal> $ qemu ... -fw_cfg name=etc/edk2/https/cacerts,file=certs.db</literal>
        </para>
        <para>
          Check more details in the &quot;HTTPS Boot&quot; section of
          <link xlink:href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/README">OVMF
          README</link>.
        </para>
      </section>
    </section>
    <section xml:id="lighttpd_1">
      <title>lighttpd</title>
      <para>
        Since lighttpd needs the private key and the certificate in the
        same file, we have to unify them first.
      </para>
      <para>
        <literal> $ cat server.crt server.key &gt; server-almighty.pem</literal>
      </para>
      <para>
        Copy &quot;server-almighty.pem&quot; to /etc/ssl/private/.
      </para>
<literallayout><literal> # cp server-almighty.pem /etc/ssl/private/</literal>
<literal> # chown -R root:lighttpd /etc/ssl/private/server-almighty.pem</literal>
<literal> # chmod 640 /etc/ssl/private/server-almighty.pem</literal></literallayout>
      <para>
        Then, check /etc/lighttpd/modules.conf whether
        &quot;mod_openssl&quot; is in the &quot;server.modules&quot;
        section or not. For example:
      </para>
<literallayout><literal> server.modules = (</literal>
<literal>   &quot;mod_access&quot;,</literal>
<literal>   &quot;mod_openssl&quot;,</literal>
<literal> )</literal></literallayout>
      <para>
        <emphasis role="strong">NOTE:</emphasis> Due to the change of
        packaging, openSUSE Leap 15.0 or the higher need to enable the
        openssl module explicitly while lighttpd in openSUSE Leap 42.3
        or the lower builds in the openssl module in the lighttpd
        binary.
      </para>
      <para>
        Next, add the following lines to &quot;SSL Support&quot; section
        in /etc/lighttpd/lighttpd.conf:
      </para>
<literallayout><literal>  # For IPv4</literal>
<literal>  $SERVER[&quot;socket&quot;] == &quot;:443&quot; {</literal>
<literal>      ssl.engine                 = &quot;enable&quot;</literal>
<literal>      ssl.pemfile                = &quot;/etc/ssl/private/server-almighty.pem&quot;</literal>
<literal>  }</literal>
<literal>  # For IPv6</literal>
<literal>  $SERVER[&quot;socket&quot;] == &quot;[::]:443&quot; {</literal>
<literal>      ssl.engine                 = &quot;enable&quot;</literal>
<literal>      ssl.pemfile                = &quot;/etc/ssl/private/server-almighty.pem&quot;</literal>
<literal>  }</literal></literallayout>
      <para>
        Restart lighttpd to activate SSL support.
      </para>
      <para>
        <literal> # systemctl restart lighttpd</literal>
      </para>
    </section>
    <section xml:id="apache2_1">
      <title>apache2</title>
      <para>
        Before we start to configure apache, we have to check
        <emphasis role="strong">/etc/sysconfig/apache2</emphasis> first.
      </para>
      <para>
        The SSL support of apache is controlled by
        <emphasis role="strong">APACHE_SERVER_FLAGS</emphasis>, so we
        have to add the <emphasis role="strong">SSL</emphasis> flag.
      </para>
      <para>
        <literal> APACHE_SERVER_FLAGS=&quot;SSL&quot;</literal>
      </para>
      <para>
        Besides, make sure that <emphasis role="strong">ssl</emphasis>
        is in <emphasis role="strong">APACHE_MODULES</emphasis>. For
        example:
      </para>
      <para>
        <literal> APACHE_MODULES=&quot;actions alias auth_basic authn_file authz_host authz_groupfile authz_core authz_user autoindex cgi dir env expires include log_config mime negotiation setenvif </literal><emphasis role="strong"><literal>ssl</literal></emphasis><literal> socache_shmcb userdir reqtimeout authn_core headers proxy proxy_http proxy_wstunnel&quot;</literal>
      </para>
      <para>
        Next, copy the private key and the certificate to /etc/apache2/.
      </para>
<literallayout><literal> # cp server.key /etc/apache2/ssl.key/</literal>
<literal> # chown wwwrun /etc/apache2/ssl.key/server.key</literal>
<literal> # chmod 600 /etc/apache2/ssl.key/server.key</literal>
<literal> # cp server.crt /etc/apache2/ssl.crt/</literal></literallayout>
      <para>
        Create the ssl vhost configuration.
      </para>
<literallayout><literal> # cd /etc/apache2/vhosts.d</literal>
<literal> # cp vhost-ssl.template vhost-ssl.conf</literal></literallayout>
      <para>
        Edit /etc/apache2/vhosts.d/vhost-ssl.conf to change the private
        key and the certificate:
      </para>
<literallayout><literal> SSLCertificateFile /etc/apache2/ssl.crt/server.crt</literal>
<literal> SSLCertificateKeyFile /etc/apache2/ssl.key/server.key</literal></literallayout>
      <para>
        Restart apache to activate the SSL support:
      </para>
      <para>
        <literal> # systemctl restart apache2</literal>
      </para>
    </section>
    <section xml:id="modify_dhcp_configuration">
      <title>Modify DHCP configuration</title>
      <para>
        Last, remember to replace the
        &quot;<link xlink:href="http://">http://</link>&quot; prefix
        with &quot;<link xlink:href="https://">https://</link>&quot; in
        the dhcpd.conf/dhcpd6.conf and restart the dhcp server.
      </para>
<literallayout><literal> # systemctl restart dhcpd</literal>
<literal> # systemctl restart dhcpd6</literal></literallayout>
    </section>
    <section xml:id="changes_in_grub.cfg">
      <title>Changes in grub.cfg</title>
      <para>
        Since we create a self-signed certificate for our HTTPS server,
        if we specify the HTTPS url in grub.cfg, the SLE/openSUSE
        installation system may fail to verify the certificate and
        refuse to download files from our HTTPS server.
      </para>
      <para>
        There are two possible solutions.
      </para>
      <para>
        1. Add <emphasis role="strong">ssl.certs=0</emphasis> to disable
        the certificate verification. For example:
      </para>
      <para>
        <literal> linuxefi /sle/boot/x86_64/loader/linux install=</literal><emphasis role="strong"><link xlink:href="https://www.httpboot.local/sle"><literal>https://www.httpboot.local/sle</literal></link></emphasis><literal> </literal><emphasis role="strong"><literal>ssl.certs=0</literal></emphasis>
      </para>
      <para>
        2. Create an initrd containing the server certificate. By
        default, the installation system searches the trusted
        certificates in /var/lib/ca-certificates/openssl/ and
        /var/lib/ca-certificates/pem/, so we have to create an initrd
        containing our server certificate in those directory. Here is
        the example of commands:
      </para>
<literallayout><literal> ## Create new directories containing the target path</literal>
<literal> $ mkdir -p initrd-new/var/lib/ca-certificates/openssl/</literal>
<literal> $ mkdir -p initrd-new/var/lib/ca-certificates/pem/</literal>
<literal> </literal>
<literal> ## Copy our server certificate to the target paths</literal>
<literal> $ cp server.crt initrd-new/var/lib/ca-certificates/openssl/my-ca.pem</literal>
<literal> $ cp server.crt initrd-new/var/lib/ca-certificates/pem/my-ca.pem</literal>
<literal> </literal>
<literal> ## Create the link file, </literal><hash><literal>.0, to make the certificate be trusted</literal>
<literal> $ ln -sr initrd-new/var/lib/ca-certificates/openssl/my-ca.pem initrd-new/var/lib/ca-certificates/openssl/`openssl x509 -hash -noout -in server.crt`.0</literal>
<literal> $ ln -sr initrd-new/var/lib/ca-certificates/pem/my-ca.pem initrd-new/var/lib/ca-certificates/pem/`openssl x509 -hash -noout -in server.crt`.0</literal>
<literal> </literal>
<literal> ## Change the working directory to 'initrd-new'</literal>
<literal> $ cd initrd-new</literal>
<literal> </literal>
<literal> ## Make sure the whole path is owned by root</literal>
<literal> $ sudo chown -R root:root var</literal>
<literal> </literal>
<literal> ## Create initrd (ssl.img)</literal>
<literal> $ find . | cpio --quiet -H newc -o | gzip -9 -n &gt; ../ssl.img</literal>
<literal> </literal>
<literal> ## Back to the upper directory for the further actions</literal>
<literal> $ cd ..</literal></literallayout>
      <para>
        You can check the content of ssl.img with
        <emphasis role="strong">lsinitrd</emphasis>. For example:
      </para>
<literallayout><literal> $ lsinitrd ssl.img</literal>
<literal> Image: ssl.img: 4.0K</literal>
<literal> ========================================================================</literal>
<literal> Version: </literal>
<literal> </literal>
<literal> Arguments: </literal>
<literal> dracut modules:</literal>
<literal> ========================================================================</literal>
<literal> drwxr-xr-x   3 johndoe  users           0 Sep  3 10:09 .</literal>
<literal> drwxr-xr-x   3 root     root            0 Sep  3 16:27 var</literal>
<literal> drwxr-xr-x   3 root     root            0 Sep  3 16:27 var/lib</literal>
<literal> drwxr-xr-x   3 root     root            0 Sep  3 16:27 var/lib/ca-certificates</literal>
<literal> drwxr-xr-x   2 root     root            0 Sep  3 16:28 var/lib/ca-certificates/openssl</literal>
<literal> lrwxrwxrwx   1 root     root            9 Sep  3 16:28 var/lib/ca-certificates/openssl/c6bea024.0 -&gt; my-ca.pem</literal>
<literal> -rw-r--r--   1 root     root         2114 Sep  3 16:28 var/lib/ca-certificates/openssl/my-ca.pem</literal>
<literal> drwxr-xr-x   2 root     root            0 Sep  3 16:28 var/lib/ca-certificates/pem</literal>
<literal> lrwxrwxrwx   1 root     root            9 Sep  3 16:28 var/lib/ca-certificates/pem/c6bea024.0 -&gt; my-ca.pem</literal>
<literal> -rw-r--r--   1 root     root         2114 Sep  3 16:28 var/lib/ca-certificates/pem/my-ca.pem</literal>
<literal> ========================================================================</literal></literallayout>
      <para>
        Now we need to copy <emphasis role="strong">ssl.img</emphasis>
        to the directory of initrd, e.g.
        /srv/www/htdocs/sle/boot/x86_64/loader/, and modify
        <emphasis role="strong">grub.cfg</emphasis> to add ssl.img. For
        example:
      </para>
<literallayout><literal> echo 'Loading kernel ...'</literal>
<literal> linuxefi /sle/boot/x86_64/loader/linux install=</literal><emphasis role="strong"><link xlink:href="https://www.httpboot.local/sle"><literal>https://www.httpboot.local/sle</literal></link></emphasis>
<literal> echo 'Loading initial ramdisk ...'</literal>
<literal> initrdefi /sle/boot/x86_64/loader/initrd </literal><emphasis role="strong"><literal>/sle/boot/x86_64/loader/ssl.img</literal></emphasis></literallayout>
      <para>
        NOTE: A simple bash script to create initrd is available:
        <link xlink:href="https://github.com/lcp/uefi-fun/blob/master/packcert/packcert.sh">https://github.com/lcp/uefi-fun/blob/master/packcert/packcert.sh</link>
      </para>
      <para>
        Usage:
      </para>
      <para>
        <literal> $ sh packcert.sh server.crt ssl.img</literal>
      </para>
    </section>
  </section>
  <section xml:id="container_services">
    <title>Container Services</title>
    <para>
      For the quick test, mightyboot(*) can create the services with
      containers. Just edit <emphasis role="strong">env</emphasis> to
      match the host network configuration and type
    </para>
    <para>
      <literal> $ docker-compose up</literal>
    </para>
    <para>
      If the settings are good, it will bring up dhcp, dhcp6, dnsmasq,
      and lighttpd services on the given network interface and make them
      ready to test.
    </para>
    <para>
      (*)
      <link xlink:href="https://github.com/lcp/mightyboot">https://github.com/lcp/mightyboot</link>
    </para>
  </section>
</section>
<section xml:id="launch_the_client">
  <title>Launch The Client</title>
  <section xml:id="physical_machine_2">
    <title>Physical Machine</title>
    <para>
      If the firmware already supports HTTPBoot, just plug in the cable
      and choose the correct boot option.
    </para>
  </section>
  <section xml:id="virtual_machine_2">
    <title>Virtual Machine</title>
    <para>
      Now it's time to set up a virtual machine as the HTTPBoot client.
      There are a few qemu options needed to create a UEFI virtual
      machine.
    </para>
    <orderedlist spacing="compact">
      <listitem>
        <para>
          Specify the firmware
        </para>
      </listitem>
    </orderedlist>
<literallayout><literal> -drive if=pflash,format=raw,readonly,file=/usr/share/qemu/ovmf-x86_64-code.bin \</literal>
<literal> -drive if=pflash,format=raw,file=ovmf-x86_64-vars.bin</literal></literallayout>
    <para>
      Please note that ovmf-x86_64-vars.bin must be writable. Just copy
      /usr/share/qemu/ovmf-x86_64-vars.bin to the working directory.
    </para>
    <orderedlist spacing="compact">
      <listitem>
        <para>
          Specify the network device
        </para>
      </listitem>
    </orderedlist>
<literallayout><literal> -netdev tap,id=hostnet0,ifname=tap0,script=no,downscript=no \</literal>
<literal> -device virtio-net-pci,romfile=,netdev=hostnet0</literal></literallayout>
    <para>
      Since the host uses tap0 to communicate with the guest, we must
      specify the interface. &quot;romfile=&quot; is to disable the iPXE
      support so the virtual machine will use the native PXE and
      HTTPBoot functions from OVMF instead from iPXE.
    </para>
    <para>
      The complete qemu command would be like this:
    </para>
<literallayout><literal> $ qemu-system-x86_64 -enable-kvm \</literal>
<literal>                      -drive if=pflash,format=raw,readonly,file=/usr/share/qemu/ovmf-x86_64-code.bin \</literal>
<literal>                      -drive if=pflash,format=raw,file=ovmf-vars.bin \</literal>
<literal>                      -hda fat:hda-contents/ -monitor stdio \</literal>
<literal>                      -netdev tap,id=hostnet0,ifname=tap0,script=no,downscript=no \</literal>
<literal>                      -device virtio-net-pci,romfile=,netdev=hostnet0</literal></literallayout>
    <para>
      If you are using libvirt, then you can use &quot;rom bar&quot; to
      disable iPXE support. For example:
    </para>
    <programlisting language="xml">
    &lt;interface type='bridge'&gt;
      &lt;mac address='00:11:22:33:44:55'/&gt;
      &lt;source bridge='br0'/&gt;
      &lt;model type='virtio'/&gt;
      &lt;rom bar='off'/&gt;
      &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/&gt;
    &lt;/interface&gt;
</programlisting>
    <para>
      When the TianoCore logo shows, press &quot;ESC&quot; to enter the
      firmware menu.
    </para>
    <para>
      Image:Boot-logo.png
    </para>
    <para>
      Press &quot;DOWN&quot; to go to &quot;Boot Manager&quot; and press
      &quot;Enter&quot;.
    </para>
    <para>
      Image:Boot-manager.png
    </para>
    <para>
      There will be several boot options. Choose the boot option with
      the &quot;HTTP&quot; prefix.
    </para>
    <para>
      For example:
    </para>
    <para>
      HTTPBoot IPv4
    </para>
    <para>
      Image:Httpv4.png
    </para>
    <para>
      HTTPBoot IPv6
    </para>
    <para>
      Image:Httpv6.png
    </para>
    <para>
      Just choose one of the boot options, and the firmware will start
      to download your UEFI application and execute it!
    </para>
    <para>
      Another way to test http boot is to download a iso image from a
      URL. The benefit of this way is that you don't need to setup DHCP
      on host machine, and it only needs http server.
    </para>
    <para>
      The first step is putting iso file to /srv/www/htdocs on server
      side:
    </para>
    <para>
      e.g. /srv/www/htdocs/openSUSE-Leap-42.1-NET-x86_64.iso
    </para>
    <para>
      On client code, you should launch UEFI firmware UI:
    </para>
    <para>
      Device Manager -&gt; Network Device List
    </para>
    <para>
      Image:Uefi-http-boot-iso-0001.png
    </para>
    <para>
      e.g. IPv4
    </para>
    <para>
      Image:Uefi-http-boot-iso-0002.png
    </para>
    <para>
      Enable DHCP or you can set static ip
    </para>
    <para>
      Image:Uefi-http-boot-iso-0003.png
    </para>
    <para>
      Create a boot option by &quot;HTTP Boot Configuration&quot;
    </para>
    <para>
      Image:Uefi-http-boot-iso-0004.png
    </para>
    <para>
      Edit &quot;Boot URI&quot;, point to the position of ISO file
    </para>
    <para>
      Image:Uefi-http-boot-iso-0005.png
    </para>
    <para>
      Select &quot;UEFI HTTP&quot; to boot to the ISO image
    </para>
    <para>
      Image:Uefi-http-boot-iso-0006.png
    </para>
  </section>
</section>
<section xml:id="see_also">
  <title>See also</title>
  <section xml:id="related_articles">
    <title>Related articles</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <link xlink:href="openSUSE:UEFI_Secure_boot_using_qemu-kvm">openSUSE:UEFI_Secure_boot_using_qemu-kvm</link>
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section xml:id="external_links">
    <title>External links</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <link xlink:href="http://www.tianocore.org/ovmf/">OVMF</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link xlink:href="http://www.linux-kvm.org/downloads/lersek/ovmf-whitepaper-c770f8c.txt">Open
          Virtual Machine Firmware (OVMF) Status Report</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link xlink:href="https://fedoraproject.org/wiki/Using_UEFI_with_QEMU">fedora:
          Using UEFI with QEMU</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link xlink:href="https://lkml.org/lkml/2016/6/3/85">LKML:
          libnvdimm, nfit: treat volatile virtual CD region as read-only
          pmem</link>
        </para>
      </listitem>
    </itemizedlist>
  </section>
</section>
</chapter>
